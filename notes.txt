================================================================================================================================================
For setting up the files for this assignment I used the following commands:

mkdir randall
cd randall
wget https://web.cs.ucla.edu/classes/spring24/cs35L/assign/randall-git.tgz
tar -xzvf randall-git.tgz
git reset --hard


================================================================================================================================================

To implement the makefile checks for testing, I did the following:

#implementation of the make check
check: randall
	@echo "Running test cases"
	@echo "Check that the number of randomly generated bytes produced by randall is correct."
	@echo "=============== TEST 1 ================="
	@./randall 40 | wc -c | grep -q '^40$$' || (echo "Output length test failed" && false)
	@echo "Tests for output length are passed."



check prints to ther terminal that the test cases are being run and the description of each test case prior to the test being ran.

In this case, randall is being run to generate 40 random bytes (./randall 40).

The output of that command is piped into wc which will count the number of bytes generated by the prior command. 
The count found from wc will be verified by the grep command to see if it is the same as the result we expected (40 bytes).

================================================================================================================================================

To refactor randall.c, I split it into the following files:

options.c, options.h, output.c, output.h, rand64-hw.c, rand64-hw.h, rand64-sw.c, rand64-sw.h.

To do this, you must incrementally separate code from randall.c into these files. I've also made sure to include necessary libraries in the header files.
Then, for the corresponding C file, you include the header file. I've also aimed for not having redundant include guards.

When I split randall into several files, I also considered how these files would affect the construction of the program for the rest of the assignment. This is why, 
for example, I included options for rdrand and ldrand48_r in my options struct in options.h. I preferred to use this method because it makes the program more malleable
for future developers who want to potentially add their own configurations to this randall program,.

I also made sure to update the compiler/linking options in the makefile so that compilation works correctly. This was done by creating a FILES object
that contains .c and .h files. Then, I updated the randall compilation to compile with *.c rather than @.c so that all C files were compiled
into the final executable.

For randall.c:
    Contains the main program and the headers from the files below. It also includes the errno header and stdio hearder because it must be able to handle
    standard input and output as well as reading error conditions. I've also adjusted main to account for the options struct that I've created which made
	parsing options easier, as explained below.


For options:
	I defined a struct for options that stores the number of bytes that will be expected to pass and an outputSize for the number of bytes that should be outputted by randall for the command.
	In order for randall to be able to interpret options correctly, I decided to create a helper function called optionsScanner which accepts 
	the number of arguments to be scanned and an array of arguments. These will be stored into the content of an options struct pointer and the contents
	of the struct are checked in randall.c.

	I've also realized that for input types, there will need to be a slight modification of the options struct. The issue is that if we were to resolve this in the randall
	main function, we would have to deal with errors there with arguments rather than being able to isolate the issue in the particular part of the options 
	file. I've decided to create an enumerated type which has a default field in the case that the user doesn't specify a randomizer -- then rdrand is used. This also 
	enumerated type will also help handle the case where rdrand is specified but not available as the user can request for that type of randomizer as well. 
	If the randomizer exists, then options struct will have its input type set correspondingly and the rest of the processing is dealt in the main function of 
	randall.



For output:
	I will further modify the way in which randall.c parses output as I get further into the second part of the assignment. However, for now, I have added
	the writeBytes function from randall.c into the header file and its implementation in the corresponding C file. 

	In addition, output has the option of being redirected to stdio or as a number of bytes via write. An enumerated type can be used to handle this that will be added
	to the options struct for similar reasons as the existence of the input enumeration type (we don't want to deal with errors for output type in main, or else debugging that
	will be very chaotic). The enumerated type can be either STDIO or WRITE and main can detect for this type when dealing with output processing. WRITE will be for the N bytes 
	option so that it will be easily distinguishable to know if N bytes need to be outputted at a time.



Debugging issues:
	I realized that the implementation will require a call to allocate memory for the output so a call to free is necessary, otherwise there are memory leaks.
	This is particularly damaging since these memory leaks will occur as a buffer leak so I didn't know at times if the issue was with the input or the output.
	I also used stack tracing to resolve this issue since I can see a step-by-step rendition of the bytes being outputted.


For rand64-hw:
	I put the function declarations in the header file and their implementations in the corresponding C file.  I've also added an extra line within the initalization
	of the hardware randomizer that returns an error message if rdrand is asked to be used but doesn't actually exist on the machine.

For rand64-sw:
	I put the function declarations in the header file and their implementations in the corresponding C file. I've also created separate files for lrand48 which is a software
	randomizer so I also added processing/testing for this in the initializer for the software randomizer, the randomizer itself, and the finalizer for the randomizer.




================================================================================================================================================
For the performance tests:

	time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null
		Results:
			16384+0 records in
			16384+0 records out
			134217728 bytes (134 MB, 128 MiB) copied, 0.94825 s, 142 MB/s

			real    0m0.995s
			user    0m0.013s
			sys     0m0.919s

	time ./randall 133562368 >/dev/null
		Results:
			real    0m4.346s
			user    0m3.462s
			sys     0m0.468s

    time ./randall 133562368 | cat >/dev/null
		Results:
			real    0m4.065s
			user    0m3.967s
			sys     0m0.253s

    time ./randall 133562368 >rand.data
		Results:
			real    0m4.033s
			user    0m3.911s
			sys     0m0.104s

>/dev/null took the shortest amount of time for the command, whereas cat >/dev/null took the longest amount of time for the command.

	Using the suggestion from the spec, I tried: 
	time ./randall -i /dev/urandom 133562368 >/dev/null
		Results:
			real    0m2.620s
			user    0m1.501s
			sys     0m0.996s

	This was faster for the user than the prior 3 commands, but is slower on the system.